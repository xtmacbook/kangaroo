#include "gli.h"
#include "common.h"
#include "log.h"
#include "gls.h"

#include <stdio.h>

void  gl_debug_msg_proc_arb(
	GLenum source,
	GLenum type,
	GLuint id,
	GLenum severity,
	GLsizei length,
	const GLchar *message,
	GLvoid *userParam)
{
	

	char * source_c = nullptr;

	switch (source)
	{
	case GL_DEBUG_SOURCE_API:
		source_c = "Calls to the OpenGL API";
		break;
	case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
		source_c = "Calls to a window-system API ";
		break;
	case GL_DEBUG_SOURCE_SHADER_COMPILER:
		source_c = "A compiler for a shading language";
		break;
	case GL_DEBUG_SOURCE_THIRD_PARTY:
		source_c = "An application associated with OpenGL";
		break;
	case GL_DEBUG_SOURCE_APPLICATION:
		source_c = "Generated by the user of this application";
		break;
	case GL_DEBUG_SOURCE_OTHER:
		source_c = "Some source that isn't one of these";
		break;
	default:
		break;
	}

	fprintf(stderr, "GL CALLBACK: %s type = 0x%x, severity = 0x%x, message = %s\n from: ",
		(type == GL_DEBUG_TYPE_ERROR ? "** GL ERROR **" : ""),
		type, severity, message,source_c);
}

struct bit_info
{
	int bit;
	const char *name;
};

const char *
bitmask_to_string(const struct bit_info bits[], int numBits, int mask)
{
	static char buffer[256], *p;
	int i;

	strcpy(buffer, "(none)");
	p = buffer;
	for (i = 0; i < numBits; i++) {
		if (mask & bits[i].bit) {
			if (p > buffer)
				*p++ = ',';
			strcpy(p, bits[i].name);
			p += strlen(bits[i].name);
		}
	}

	return buffer;
}

LIBENIGHT_EXPORT void GL_X::testOpenGl()
{
	printf("Vendor: %s \n", glGetString(GL_VENDOR));
	printf("Render Name (GPU Name): %s \n", glGetString(GL_RENDERER));

	//version the current GL context is providing,
	//not necessarily the highest version your GL implementation is supporting.
	//glGetString(GL_VERSION) need called after the window be created
	//and set current GL context
	const GLubyte * byte = glGetString(GL_VERSION); //<major version>.<minor versino>
	printf("openGL current version:%s \n", byte);

#ifdef GL_VERSION_2_0  //glsl version
	{
		if (byte[0] * 10 + byte[2] >= 20) {
			const GLubyte *slv = glGetString(GL_SHADING_LANGUAGE_VERSION);
			printf("glsl version:  = %s\n", slv);
		}
	}
#endif

	int version = (byte[0] - '0') * 10 + (byte[2] - '0');

#ifdef GL_VERSION_3_0
	if (version >= 30) {
		GLint flags;
		glGetIntegerv(GL_CONTEXT_FLAGS, &flags);

		static const struct bit_info bits[] = {
			{ GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT, "forward-compatible" },
			{ GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB, "robust-access" },
			{ GL_CONTEXT_FLAG_DEBUG_BIT, "debug" }
			//{ GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR, "no-error" },
		};

		printf("context flag :%s \n", bitmask_to_string(bits, ELEMENTS(bits), flags));
	}
#endif

#ifdef GL_VERSION_3_2
	if (version >= 32) {
		GLint profile;
		glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &profile);

		static const struct bit_info bits[] = {
#ifdef GL_CONTEXT_CORE_PROFILE_BIT
			{ GL_CONTEXT_CORE_PROFILE_BIT, "core profile" },
#endif
#ifdef GL_CONTEXT_COMPATIBILITY_PROFILE_BIT
			{ GL_CONTEXT_COMPATIBILITY_PROFILE_BIT, "compatibility profile" }
#endif
		};

		printf("context supports profile is %s \n", bitmask_to_string(bits, ELEMENTS(bits), profile));
	}
#endif

#ifdef GL_VERSION_4_3
	int majorVersion, minorVersion;
	glGetIntegerv(GL_MAJOR_VERSION, &majorVersion);
	glGetIntegerv(GL_MINOR_VERSION, &minorVersion);
	if (majorVersion >= 4 && minorVersion >= 3)
	{
		int numShadingLangVersions;
		glGetIntegerv(GL_NUM_SHADING_LANGUAGE_VERSIONS, &numShadingLangVersions); //4.3 above support this

		for (int i = 0; i < numShadingLangVersions - 1; i++)
		{
			const char* version = (char*)glGetStringi(GL_SHADING_LANGUAGE_VERSION, i);
			if (version)
				printf("Support glsl version is: %s \n", version);
		}
	}

#endif // GL_VERSION_4_3


#ifdef SHOW_EXTENSION
	GLint numEx = 0;
	glGetIntegerv(GL_NUM_EXTENSIONS, &numEx);

	for (GLint i = 0; i < numEx; i++)
	{
		printf("Extension :%d : %s \n", i, glGetStringi(GL_EXTENSIONS, i));
	}
#endif // SHOW_EXTENSION
}

bool GL_X::initGlew()
{
	if (isGlewInit) return true;

	glewExperimental = GL_TRUE;
	if (glewInit() != GLEW_OK)
	{
		PRINT_ERROR("glew init error!");
		return  false;
	}
	isGlewInit = true;
	return  true;
}

bool GL_X::isSupportExtension(const char*ext)
{
	return glewGetExtension(ext);

	//Platform Specific Extensions

	//WGLEW_{extension name} or GLXEW_{extension_name}
}

LIBENIGHT_EXPORT void GL_X::init_opengl_dbg_win(bool syn)
{
	if (glDebugMessageControlARB
		&& glDebugMessageCallbackARB
		&& glDebugMessageInsertARB)
	{
		glEnable(GL_DEBUG_OUTPUT);
		glDebugMessageCallbackARB((GLDEBUGPROC)gl_debug_msg_proc_arb, 0);
		glDebugMessageControlARB(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, 0, GL_TRUE);
		if (syn)
			glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
	}
	else
	{
		PRINT_MSG("No Debug Context support! \n");
	}
}

void enableDebugOutput(bool debug)
{
	/**
	* Debug Output is an OpenGL feature that makes debugging and optimizing OpenGL applications easier.
	*/
	if (debug) glEnable(GL_DEBUG_OUTPUT);
	else glDisable(GL_DEBUG_OUTPUT);

}

bool GL_X::isSupportMultisampling()
{
	GLint sb;
	glGetIntegerv(GL_SAMPLE_BUFFERS, &sb);
	return (sb == 1);
}

size_t GL_X::glTypeSize(unsigned int type)
{
	size_t size;
#define CASE(Enum, Count, Type) \
case Enum: size = Count * sizeof(Type); break

	switch (type)
	{
		CASE(GL_FLOAT, 1, GLfloat);
		CASE(GL_FLOAT_VEC2, 2, GLfloat);
		CASE(GL_FLOAT_VEC3, 3, GLfloat);
		CASE(GL_FLOAT_VEC4, 4, GLfloat);

		CASE(GL_INT, 1, GLint);
		CASE(GL_INT_VEC2, 2, GLint);
		CASE(GL_INT_VEC3, 3, GLint);
		CASE(GL_INT_VEC4, 4, GLint);

		CASE(GL_UNSIGNED_INT, 1, GLuint);
		CASE(GL_UNSIGNED_INT_VEC2, 2, GLuint);
		CASE(GL_UNSIGNED_INT_VEC3, 3, GLuint);
		CASE(GL_UNSIGNED_INT_VEC4, 4, GLuint);

		CASE(GL_BOOL, 1, GLboolean);
		CASE(GL_BOOL_VEC2, 2, GLboolean);
		CASE(GL_BOOL_VEC3, 3, GLboolean);
		CASE(GL_BOOL_VEC4, 4, GLboolean);

		CASE(GL_FLOAT_MAT2, 4, GLfloat);
		CASE(GL_FLOAT_MAT2x3, 6, GLfloat);
		CASE(GL_FLOAT_MAT2x4, 8, GLfloat);

		CASE(GL_FLOAT_MAT3, 9, GLfloat);
		CASE(GL_FLOAT_MAT3x2, 6, GLfloat);
		CASE(GL_FLOAT_MAT3x4, 12, GLfloat);

		CASE(GL_FLOAT_MAT4, 16, GLfloat);
		CASE(GL_FLOAT_MAT4x2, 8, GLfloat);
		CASE(GL_FLOAT_MAT4x3, 12, GLfloat);
#undef CASE
	default:
		break;

	}
	return size;
}
